 # 井字棋视觉识别与控制系统

## 📖 项目概述

本项目是一个基于 OpenCV 的井字棋（Tic-Tac-Toe）视觉识别系统。它通过摄像头实时监控棋盘，能够自动检测棋盘和棋格的位置，识别玩家（人类）的落子，并能通过串口与下位机（如 Arduino、STM32 单片机）通信，以控制机械臂等执行机构完成机器人方的落子动作。

该系统是"视觉-决策-控制"一体化方案的典型应用，旨在将计算机视觉技术与物理世界的机器人控制相结合。

## ✨ 主要功能

- **自动棋盘检测**: 程序启动后能自动在摄像头视野中定位井字棋盘和九个棋格。
- **实时状态追踪**: 持续监控每个格子的状态（空格、人类棋子、机器人棋子）。
- **落子与移动检测**: 能够区分是"新落子"还是"棋子被移动"，并精确识别新落子的位置。
- **棋子颜色识别**: 能够区分代表人类的棋子（白色）和代表机器ンの棋子（黑色）。
- **串口通信**: 封装了简洁的串口通信协议，用于向上位机发送控制指令（如移动棋子）和接收执行结果。
- **逻辑校验**: 包含基础的对弈逻辑，如防止同一方连续落子。
- **可视化调试**: 提供了多个调试窗口，可以实时查看图像预处理、颜色掩码、状态识别等中间过程，方便调试和参数标定。

## 🤖 工作流程

系统的工作流程可以分为两个主要阶段：**初始化** 和 **主检测循环**。其核心思想是 **先全局后局部，由面到点**，极大地提高了检测效率和准确性。

### 阶段一：初始化 (定位棋盘，缩小范围)

这是程序启动后的第一步，目标是让系统"认识"棋盘，并将后续的计算量限制在棋盘区域内。

1.  **启动摄像头**: 程序首先打开指定的摄像头。
2.  **寻找棋盘 (`detector.init`)**: 系统会持续分析摄像头画面，直到成功识别出棋盘。
    - **图像预处理 (`pretreatment.py`)**: 每一帧图像都会经过一系列处理，以增强棋盘背景（本项目中为红色）的特征。
    - **棋盘轮廓识别**: 通过 `cv2.findContours` 找到图像中最大的、符合特征的轮廓，并将其识别为棋盘的边界。 **这一步是关键，它将后续的识别范围从整个摄像头画面缩小到了小小的棋盘区域。**
    - **获取九宫格ROI**: 在已识别的棋盘轮廓内部，通过反向掩码和轮廓查找，进一步识别出 9 个棋格。
    - **存储信息**: 成功识别后，系统会计算并存储每个棋格的精确轮廓（ROI, Region of Interest），为后续的对弈检测提供依据。
3.  **初始化成功**: 当 9 个棋格的ROI全部被成功定位后，初始化阶段结束，程序进入主循环。

### 阶段二：主检测循环 (基于"空格检测"的对弈分析)

初始化成功后，程序进入一个无限循环。在对弈检测中，我们采用了一种巧妙的 **"空格子检测"** 思路，避免了复杂的棋子颜色比对和位置遍历。

1.  **核心思路：只看空格**：我们不关心每个格子里是什么颜色的棋子，只关心 **哪些格子是空的**。通过追踪空格子的变化，就能推断出棋局的进展。
2.  **检测空格状态 (`detect_empty_grids`)**: 在每一轮检测中，程序遍历九个格子的ROI，判断其是否为空。
    - 通过分析格子内的红色背景像素比例，如果红色像素多，则为空 (`EMPTY`)；反之则为有子 (`OCCUPIED`)。
3.  **智能判断行为 (`detect_moved_pieces`)**: 程序通过比较 **上一帧** 和 **当前帧** 的空格子变化来判断玩家的行为：
    - **棋子移动**: 如果空格子的 **数量不变**，但 **位置变了**（例如，上一帧3号位是空的，这一帧变成了5号位是空的），系统就判定为一次"棋子移动"。
    - **新落子**: 如果空格子的 **数量减一**，系统则判定为一次"新落子"，并记录下那个从"空"变为"非空"的格子位置。
4.  **处理落子事件**:
    - 如果检测到"新落子"，程序 **仅对这一个新出现的棋子** 进行颜色识别 (`detect_piece_color`)，判断是 `HUMAN` 还是 `ROBOT`。
    - **合法性检查**: 系统会检查本次落子的颜色是否和上一回合相同。如果是，则判定为"重复落子"，属于无效操作。
    - **触发机器人**: 如果检测到是人类玩家的合法落子，系统会调用 `send_robot_move_command` 函数。
5.  **发送串口指令 (`send_robot_move_command`)**:
    - 该函数根据预设的协议（`[0xAA, 起始位置, 目标位置, 0x55]`）组装指令。
    - 发送指令后，系统会进入 **等待状态 (`waiting_for_robot_move`)**，暂停视觉检测，直到收到下位机返回的完成信号。
6.  **接收串口数据 (`receive_data`)**:
    - 主循环会不断检查串口是否有数据返回。
    - 当收到预设的完成信号后，系统会解除等待状态，恢复视觉检测，等待人类玩家的下一步操作。

## 📂 文件结构与核心模块

-   `ChessDetector.py`: **核心控制模块 (大脑)**
    -   管理整个游戏的状态机（`prev_state`, `current_state`）。
    -   调用其他模块，编排"初始化"和"检测循环"的整体逻辑。
    -   实现高层的游戏逻辑，如判断落子、触发机器人等。
    -   包含主程序入口 `